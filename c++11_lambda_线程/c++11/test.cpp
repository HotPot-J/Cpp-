#define _CRT_SECURE_NO_WARNINGS 1
#pragma once
#include<iostream>
#include<algorithm>
using namespace std;
/*
一、lambda表达式：
	[capture-list]（parameters）mutable -> return-type {statement}
		
		[capture-list]：捕捉列表，该列表总是出现在lambda函数的开始位置，编译器
	根据[]来判断接下来的代码是否为lambda函数，捕捉列表能够捕捉上下文中的变量
	供lambda函数使用。
		
		（parameters）：参数列表。与普通函数的参数列表一致，如果不需要参数，
	则可以连同()一起省略

		mutable：默认情况下lambda函数总是一个const函数，mutable可以取消其常量性。
	使用该修饰符时，参数列表不可省略(即使参数为空)

		{statement}：函数体。在该函数体内，除了可以使用其参数外，还可以使用
	所捕获到的变量。

注意：在lambda函数定义中，参数列表和返回值类型都是可选部分，而捕捉列表和函数体可以为空。
（c++11中最简单的lambda函数为： []{};  该函数不能做任何事情）

实质是一个匿名函数。
*/


/*
捕捉列表描述了上下文中那些数据可以被lambda使用，以及使用的方式传值
还是传引用。
[var]：表示值传递方式捕捉变量var
[=]：表示值传递方式捕获所有父作用域中的变量(包括this)
[&var]：表示引用传递捕捉变量var
[&]：表示引用传递捕捉所有父作用域中的变量(包括this)
[this]：表示值传递方式捕捉当前的this指针

a.父作用域指包含lambda函数的语句块
b.语法上捕捉列表可由多个捕捉项组成，并以逗号加以分割。
比如：[=,&a,&b] 以引用传递的方式捕捉变量a和b，值传递方式捕捉其他所有变量
c.捕捉列表不允许变量重复传递，否则就有可能导致编译错误
比如:[=,a]  =已经以传值方式捕捉了所有变量，捕捉a重复
d.在作用域以外的lambda函数捕捉列表必须为空
e.在块作用域中的lambda函数仅能捕捉父作用域中局部变量，捕捉任何非此作用域或非局部变量
都会导致编译报错
f.lambda表达式不能相互赋值： 
比如：auto fun1 = [&](int c){b = a + c; };auto fun2 = [&](int c){b = a + c; };
fun1 = fun2 （编译报错）  
*/
void test1(){
	//最简单的lambda表达式，该lambda表达式没有任何意义
	[]{};

	//省略参数列表和返回值类型，返回值类型由编译器推导为int
	int a = 1, b = 2;
	[=]{return a + 3; }; 

	//省略了返回值类型，无返回值类型
	auto fun1 = [&](int c){b = a + c; };
	fun1(10);
	cout << a << " " << b << endl;

	//各部分都很完善的lambda函数
	auto fun2 = [=, &b](int c)->int{return b += a + c; };
	cout << fun2(20) << endl;

	//赋值捕捉x
	int x = 10;
	auto add_x = [x](int a) mutable{x *= 2; return a + x; };
	cout << add_x(10) << endl;
}

//int main(){
//	test1();
//	return 0;
//}

/*
函数对象（仿函数）与lambda表达式：
	lambda底层为仿函数
	看下例：
*/

struct fruit{
	string _name;
	double _price;
};
//仿函数（其实就是重载了（）使其用起来想函数一样）
struct compare
{
	bool operator()(const fruit& l, const fruit& r){
		return l._price <= r._price;
	}
};

//int main(){
//	fruit a[] = { { "苹果", 2.0 }, { "葡萄", 1.6 }, { "樱桃", 3 } };
//	//使用仿函数比较
//	sort(a, a + sizeof(a) / sizeof(a[0]), compare());//1.6 2.0 3.0
//	
//	
//	//使用lambda表达式
//	//直接使用更为方便可读
//	/*sort(a, a + sizeof(a) / sizeof(a[0]), [](const fruit& l, const fruit& r)->bool
//	{return l._price >= r._price; }); //3.0 2.0 1.6*/
//    
//	//先定义，后使用 （为了看到反汇编的转换为仿函数的过程） 
//	auto b = [](const fruit& l, const fruit& r)->bool{
//		return l._price >= r._price;
//	};
//	sort(a, a + sizeof(a) / sizeof(a[0]), b);
//
///*
//反汇编可以看到，lambda表达式底层其实就是一个仿函数
//003784E3  mov         eax,dword ptr [l]
//003784E6  mov         ecx,dword ptr [r]
//003784E9  movsd       xmm0,mmword ptr [eax+20h]
//003784EE  comisd      xmm0,mmword ptr [ecx+20h]
//003784F3  jb          <lambda_cda72f27c233cd2fe8acf0f608a17ec3>::operator()+41h (0378501h)
//003784F5  mov         dword ptr [ebp-0D0h],1
//003784FF  jmp         <lambda_cda72f27c233cd2fe8acf0f608a17ec3>::operator()+4Bh (037850Bh)
//00378501  mov         dword ptr [ebp-0D0h],0
//0037850B  mov         al,byte ptr [ebp-0D0h]
//	*/
//	
//	return 0;
//} 


//------------------------------------------------------------------------

/*
二、c++11线程库: （跨平台，面向对象封装的类（每个线程是一个类对象））
	c++11中的重要特性之一就是对线程进行支持了，使得c++在并行编程时不需要
	依赖第三方库，要使用标准库，必须包含<thread>头文件

	1.线程是操作系统中的一个概念，线程对象可以关联一个线程，用来控制线程
	以及获取线程的状态。
	2.当创建一个线程对象后，没有提供线程函数，该对象实际没有对应任何线程
	
	注：thread类是防止拷贝的，不允许拷贝构造以及赋值，但是可以移动构造和
	移动赋值，即将一个线程对象关联线程的状态转移给其他线程对象，转移期间
	不影响线程执行

	基本函数介绍：
		thread() 
		构造一个线程对象，没有关联任何线程函数，即没有启动任何线程

		thread(fn,args1,args2,...)
		构造一个线程对象，并关联线程函数fn，args1，args2...作为线程函数的参数

		get_id() 
		获取线程id

		jionable() 
		该函数是否还在执行 joinable代表的是一个正在执行中的线程
		可以通过joinable()函数判断线程是否有效，无效的情况：
		* 采用无参构造函数的线程对象
		*线程对象的状态已经转移给其他线程对象
		*线程以及调用jion或者detach

		join() 
		该函数调用后会阻塞主线程，当该线程结束后 主线程继续执行

**启动一个线程后，当这个线程结束的时候，如何去回收线程所使用的资源呢？
		1. join()方式：（线程默认为joinable属性，所以可直接使用join）
			主线程被阻塞，当新线程终止时，join()会清理相关的线程资源，
			然后返回，主线程继续向下执行，然后销毁线程对象。由于join()
			清理了线程的相关资源，thread对象与已销毁的线程就没关系了
			（因此，一个线程对象只能使用一次join()，否则会崩溃）
		2.detach()方式（该函数会自动改变joinable属性为detached属性，然后进行线程分离）
		在创建线程对象后马上调用，用于把被创建线程与线程对象分离开，
		，新线程不在被线程对象所表达，就不能通过线程对象控制线程了，
		新线成会在后台允许，其所有控制权会交给c++运行库，由c++运行库
		保证，当线程退出时，其相关资源都能正确回收
		（分离的线程变为后台线程，创建的线程"死活"与主线程无关）
	   *所以在线程对象销毁前，要么以join()方式等待线程结束，要么以detach()
	方式将线程与对象分离。
	    
*互斥锁：
	#include<mutex>
	std::mutex  该类之间不能拷贝，也不能进行移动
	常用接口：
	lock() 上锁:锁住互斥量
	unlock() 解锁：释放对互斥量的所有权
	try_lock() 尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞

	当线程调用lock()的三种情况：
		1.如果该互斥量当前未被锁，则调用线程将该互斥量锁住，直到调用unlock
		之前，该线程一直拥有该锁
		2.如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住
		3.如果当前互斥锁被当前调用线程锁住，则会产生死锁：
		
	线程函数调用try_lock()时，可能会发生以下三种情况：
        1.如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线
		程调用 unlock 释放互斥量
        2.如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不
		会被阻塞掉
        3.如果当前互斥量被当前调用线程锁住，则会产生死锁	

**产生死锁的四个必要条件:
 1.互斥条件：进程对所分配到的资源不允许其他线程进行访问，若其他线程访问
 该资源，只能等待，直至占有该资源的进程使用完成后释放该资源
 2.占有并等待：进程获得一定的资源之后，又对其他资源发出请求，但是该
 资源可能被其他进程占有，此时请求阻塞，但又对自己获得的资源保持不放
 3.不可抢占：是指进程已获得的资源，在未完成使用之前，不可被剥夺，
 只能在使用完后自己释放
 4.循环等待条件：是指进程发生死锁后，必然存在一个进程--资源
  之间的环形链，简单讲就是你等我的资源，我等你的资源，大家一直等。

**预防死锁：
	1.破坏"互斥条件"：（但是互斥条件被破环那就没有上锁的意义了，因此实际
	应用中不能如此）
	2.破坏"占有并等待条件":想出一个办法，组织线程在持有资源的同时申请其他
	资源
	方法一：创建进程时，要求它申请所需的全部资源，系统或满足其他所有要求，
	或者什么都不给。（一次性分配方案）
	方法二：要求每个线程提出新的资源申请前，释放它所占的资源。这样，一个
	进程在需要资源a时，须要先把它先前占的资源b释放掉，然后再对b进行申请（即使它很快又需要申请资源a）
	3.破坏"不可抢占条件"：允许对资源实施抢占
	方法一：如果占有某些资源的一个线程进行进一步资源请求被拒绝，则该线程必须
	释放现有资源，如有比要，可再次请求这些资源和另外的资源。
	方法二：（优先级都不同时）如果一个线程请求当前被另外一个进程所占有的
	一个资源，则操作系统可以抢占另一个线程，要求他释放资源。
	4.破坏"循环等待"条件：将操作系统中的所有资源统一编号，进程可在任和时间
	提出资源申请，但是所有申请必须按照资源的编号顺序(升序)提出。这样做就能保证
	系统不能出现死锁。（所谓循环就是，我有1需要2，他有2需要1，谁都不让谁
	当我们采用编号（升序），就是我有1才能申请2，就避免了循环等待，那么就可以
	让未申请到的线程阻塞到资源被用完的时候去尝试申请）

**避免死锁：
	常用的技术：
		1.加锁顺序：线程按照一定的顺序加锁

		2.加锁时限：线程尝试获取锁的时候加上一定时限，超过时限则放弃对该
		锁的请求，并释放占有锁
	c++11提供了 std::timed_mutex 对比std::mutex多了两个成员函数：
		try_lock_for():
			接受一个时间范围，表示在这一段时间范围之内线程如果没有获得锁则被阻塞住（与 std::mutex
        的 try_lock() 不同，try_lock 如果被调用时没有获得锁则直接返回 false），如果在此期间其他线程
       释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返
       回 false

	   try_lock_until()
	   接受一个时间点作为参数，在指定时间点未到来之前线程如果没有获得锁则被阻塞住，如果在此期
	   间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得
	   锁），返回falses

		3.死锁检测
*/

#include<thread>
#include<mutex>
int x = 0;//定义一个公共资源
mutex mtx; //定义一个互斥锁  保证线程安全
void Add(int n){
	//入口函数
	for (int i = 0; i < n; ++i){
		mtx.lock(); //加锁 
		++x;
		mtx.unlock();//解锁
	}
	
}

//int main(){
//	thread t1(Add, 50); //构造一个线程对象t1（）
//	thread t2(Add, 50);
//
//	// 阻塞主线程
//	//（让主程等一下子线程，然后该函数会清理该线程的资源，主线程继续向下执行）
//	t1.join();
//	t2.join();
//	cout << x << endl; //各加了50次 
//	return 0;
//}

/*
	**原子性操作库（atomic）
	多线程最主要的问题就是共享数据带来的安全性问题（线程安全）
	虽然加锁可以解决，但是加锁的缺陷就是资源访问的互斥性，只要一个线程在
	对a++时候，其他线程会因为无法访问a而阻塞，会影响效率，且控制不好锁容易
	造成死锁。
	c++11中引用了原子操作。所谓原子操作：不可被终端的一个或一系列操作，
	是的线程间数据第同步变得非常高效。
	atomic支持很多类型:  
		atomic_bool atomic_char atomic_in......具体可查cplusplus
	用法例子: atomic<int> x; 定义一个int类型的原子变量
*/

//thread+vector+lambda+原子性操作库（atomic）用法：
#include<iostream>
#include<vector>
#include<thread>
#include<atomic>
using namespace std;
//int main(){
//	atomic<int> x = 0;
//	//m个线程对x加n次
//	int m = 0, n = 0;
//	cin >> m >> n;
//	vector<thread> arr(m);
//	for (int i = 0; i < m; ++i){
//		//这是不是深拷贝的拷贝赋值和拷贝构造（thread也不支持）
//		//而是移动赋值和移动拷贝（浅拷贝，右值引用 ）把将亡值的资源 状态转移给了其他线程
//		arr[i]=thread([&x](int count){
//			for (int i = 0; i < count; ++i){
//				++x;
//			}
//		}, n);
//	}
//	for (auto& e : arr){
//		cout << e.get_id() << ".join" << endl;
//		e.join();
//	}
//	cout << x << endl; 
//	return 0;
//}


/*
条件变量:
	当一个线程互斥的访问某个变量时，他可能发现在其他线程改变状态之前，它
	什么也做不了。 例如一个线程访问队列时，发现队列为空，它只能等待，直到
	其他线程将一个节点添加到队列中。这种情况就需要用到条件变量。
	即：a用x资源的时候，a就出等待队列。b想要访问x，此时x被使用，那么b就进
	等待队列，等待被唤醒。当a使用完了 就会唤醒等待队列中等待的b 
	（队列-》先进先出）

同步概念与静态条件：
	同步:在保证数据安全的前提下，让线程能够按照某种特定的顺序访问临界资源
	从而有效的避免饥饿问题。
	竞态条件：因为时序问题，而导致程序异常，我们称之为竞态条件。

c++11中：condition_variable类中封装了条件变量
	
*/

//题目:使用两个线程，一个打印奇数 一个打印偶数 （0-n的顺序打印）

#include<iostream>
#include<thread>
#include<mutex>
#include<condition_variable>
using namespace std;

int main(){
	//定义两个互斥锁
	mutex m1, m2;
	//定义两个条件变量
	condition_variable cv1, cv2;
	int n = 0;
	cin >> n;
	//先执行线程t1（从0开始顺序打印）
	thread t1([&](){
		for (int i = 0; i <=n; i += 2){
			cout << i << endl;
			cv2.notify_one();//唤醒等待队列中的线程cv2
			cv1.wait(unique_lock<mutex>(m1)); //进入等待队列
		}
	});

	thread t2([&](){
		//为了让其后执行，直接让该线程进入等待队列
		for (int i = 1; i <=n; i += 2){
			cv2.wait(unique_lock<mutex>(m2));
			cout << i << endl;
			cv1.notify_one();//唤醒等待队列中的线程cv1
		}
	});
	t1.join();
	t2.join();	
	return 0;
}