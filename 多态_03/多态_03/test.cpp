#define _CRT_SECURE_NO_WARNINGS 1
#include<iostream>
using namespace std;
//多态的原理：
/*
1.虚函数表:
	//sizeof(Base)的值为多少?
	class Base
	{
		public:
			virtual void Func1(){
			cout<<"jxy"<<endl;
			}

			virtual void Func2(){
			cout<<"j"<<endl;
			}
		private:
			int a = 1;
			char b = 'a';
	};
	正确答案应为: 12  

	原因:
		在多态机制下，会有一个数组指针指向虚函数表（该表为指针数组，也叫做虚表）
		而这些虚函数的地址存放在虚表中，所以多态类的大小与虚函数的个数无关，只与
		这个数组指针有关。
		一个数组指针为4个字节，int a为4个字节，char b为一字节，根据内存对齐原则
		自动补齐3个字节，Base类一共为12个字节
		
	**对于继承部分内存对齐的拓展:
		class a{
			protected:
				int aa;
				char aaa;
		};
		class b:public a{
			protected:
				char bb;
		};
		class c:public b{
			protected:
				char cc;
		};
		sizeof(c)为多少?
			g++：8
			win：16
			**原因为:在g++下，编译器先继承再内存对齐 其吧int aa、  char aaa、 char bb 、char cc
					 看作整体，4+1+1+1 = 7 再补齐为8
					 在win下，编译器先对齐再继承，class a内存对齐后大小为8 class b继承a 大小为12 
					 同理 c的大小最终为16

总结：
	1.派生类对象中也有一个虚表指针，派生类对象由两部分构成: 一部分是父类继承
	下来的成员，虚表指针也就是存在该部分的，另一部分是自己的成员

	2.基类对象和派生类对象虚表是不一样的，当派生类对象重写了基类的虚函数，那么
	派生类对象中的虚表中存放的是重写的虚函数。

	3.基类中不是虚函数的函数，被派生类继承下来后是不会被放进虚表中的

	4.虚函数表本质是一个存虚函数指针的指针数组，这个数组最后存放了一个nullptr
	
	5.派生类虚表生成: a.先将基类中的虚表内容拷贝一份到派生类虚表中。
					  b.如果派生类重写了基类中某个虚函数，用派生类自己的虚函数覆盖虚表中基类的虚函数
					  c.派生类自己新增加的虚函数按其在派生类中的声明次序增加到派生类虚表的最后

	**虚函数和虚表分别存在哪里？
		虚函数和普通函数一样存在代码段，而指向它的指针存在虚表中。vs下虚表存在代码段

	**对象中存的是指向虚表（指针数组）的指针（数组指针），虚表中存的是指向虚函数的指针，
	
多态的原理:
	就是指针或者引用指向那个对象，就去那个对象中找到对应的
	虚函数来进行调用。
	多态是一种运行时调用，运行起来以后去虚表中找到要调用的虚函数
*/
